# 作业1
给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

如果用哈希表的方式，虽然不符合题目对**常量额外空间**的要求（因为哈希表需要额外空间），但思路非常直观，可以按以下步骤实现：

---
## 实现思路

### **哈希表实现思路（不考虑空间限制）**

#### **1. 统计频率**
- 创建一个哈希表（如 Python 的 `dict` 或 Java 的 `HashMap`），键是数组中的数字，值是该数字出现的次数。
- 遍历数组 `nums`，对每个数字 `num`，更新哈希表：
  - 如果 `num` 不在哈希表中，添加 `num: 1`；
  - 如果 `num` 已存在，将计数加 1（即 `count[num] += 1`）。

#### **2. 查找唯一元素**
- 再次遍历哈希表，找到计数为 1 的键，即为答案。

---

### **示例**
以 `nums = [4, 1, 2, 1, 2]` 为例：

1. **统计频率**：
   - 遍历数组：
     - 4: 出现 1 次 → `{4: 1}`
     - 1: 出现 1 次 → `{4: 1, 1: 1}`
     - 2: 出现 1 次 → `{4: 1, 1: 1, 2: 1}`
     - 1: 出现 2 次 → `{4: 1, 1: 2, 2: 1}`
     - 2: 出现 2 次 → `{4: 1, 1: 2, 2: 2}`
   - 最终哈希表：`{4: 1, 1: 2, 2: 2}`

2. **查找唯一元素**：
   - 遍历哈希表，发现 `4` 的计数是 1，返回 `4`。

---

### **复杂度**
- **时间复杂度**：O(n)（遍历数组一次 + 遍历哈希表一次）。
- **空间复杂度**：O(n)（最坏情况下哈希表存储 n/2 + 1 个键值对）。

---

### **代码框架（伪代码）**
```python
def find_unique(nums):
    count = {}
    for num in nums:
        count[num] = count.get(num, 0) + 1
    for num, freq in count.items():
        if freq == 1:
            return num
```

---

### **总结**
哈希表方法简单直接，但需要额外空间。如果**放宽空间限制**，这是最优解之一；但题目要求**常量空间**，因此需改用**异或操作**（O(1) 空间）。


# 作业2
考察：数字操作、条件判断
题目：判断一个整数是否是回文数 

### 思路：判断整数是否是回文数（不转成字符串）

**核心思想**：  
将整数的后半部分数字**反转**，然后与前半部分比较。如果相等，则是回文数。

---

#### **步骤分解**：
1. **处理特殊情况**：
   - 负数：直接返回 `false`（负号 `-` 不是数字，无法对称）。
   - 末尾是 0 的非零数：直接返回 `false`（如 10、100，反转后变成 01、001，不对称）。

2. **反转后半部分数字**：
   - 初始化 `reversed = 0`（存储反转的后半部分）。
   - 循环终止条件：当 `x <= reversed` 时，说明已经反转了一半的数字。
     - 每次循环：
       - 取出 `x` 的最后一位：`last_digit = x % 10`。
       - 将 `last_digit` 拼接到 `reversed`：`reversed = reversed * 10 + last_digit`。
       - 去掉 `x` 的最后一位：`x = x // 10`。

3. **比较前后两半**：
   - 偶数位：直接比较 `x == reversed`（如 1221 → 反转后为 12 和 12）。
   - 奇数位：去掉 `reversed` 的最后一位再比较（如 12321 → 反转后为 12 和 123，去掉 3 后比较 12 和 12）。

---

#### **示例验证**：
- **输入 121**：
  - 初始 `x=121`, `reversed=0`。
  - 第1次：`last_digit=1`, `reversed=1`, `x=12`。
  - 第2次：`last_digit=2`, `reversed=12`, `x=1`。
  - 终止（`x=1 <= reversed=12`）。此时 `x=1`, `reversed=12`（奇数位），去掉 `reversed` 的最后一位得 `1`，比较 `1 == 1`，返回 `true`。

- **输入 10**：
  - 末尾是 0，直接返回 `false`。

- **输入 -121**：
  - 负数，直接返回 `false`。

---

#### **关键点**：
- **不转成字符串**：全程用数学运算（取余 `%` 和整除 `//`）。
- **O(1) 空间**：仅用两个变量 `x` 和 `reversed`。
- **O(log n) 时间**：数字的位数是 log₁₀(n) 级别。
